int rem(int x, int y)
{
    return (x % y + y) % y;
}

__kernel
void fdtdKernel(__global int* idGrid, __global float* modelGrid, __global float* boundaryGrid, int idxRotate, int idxSample, __global float* input, __global float* output, int inputPosition, int outputPosition, int numConnections, int* connections, float lambda, float mu, float stringMu, float stringLambda, float deltaT, float muTwo, float sigma)
{
if(get_global_id(0) == 0 || get_global_id(1) == 0 || get_global_id(0) == get_global_size(0) || get_global_id(1) == get_global_size(1) || get_global_id(0) == 1 || get_global_id(0) == get_global_size(0)-1 || get_global_id(1) == 1 || get_global_id(1) == get_global_size(1)-1 )
		return;
	//Rotation Index into model grid//
	int gridSize = get_global_size(0) * get_global_size(1);
    
	int rotation0 = gridSize * rem(idxRotate+0, 3);
	int rotationM1 = gridSize * rem(idxRotate+-1, 3);
	int rotation1 = gridSize * rem(idxRotate+1, 3);
	
    
	//Get index for current and neighbouring nodes//
	int t0x0y0Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+0);
	int tM1x0y0Idx = rotationM1 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+0);
	int t0x0y1Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+1);
	int t0x0yM1Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+-1);
	int t0x1y0Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+0);
	int t0xM1y0Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+0);
	int t0x0y2Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+2);
	int t0x0yM2Idx = rotation0 + ((get_global_id(1)+0) * get_global_size(0) + get_global_id(0)+-2);
	int t0x2y0Idx = rotation0 + ((get_global_id(1)+2) * get_global_size(0) + get_global_id(0)+0);
	int t0xM2y0Idx = rotation0 + ((get_global_id(1)+-2) * get_global_size(0) + get_global_id(0)+0);
	int t0x1y1Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+1);
	int t0x1yM1Idx = rotation0 + ((get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+-1);
	int t0xM1y1Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+1);
	int t0xM1yM1Idx = rotation0 + ((get_global_id(1)+-1) * get_global_size(0) + get_global_id(0)+-1);
	
	int t1x0y0Idx = rotation1 + ((get_global_id(1)) * get_global_size(0) + get_global_id(0));

	//Boundary condition evaluates neighbours in preperation for equation//
	//@ToDo - Make new timestep value autogenerated?//
	float t1x0y0;
	float t0x0y0;
	float tM1x0y0;
	float t0x0y1;
	float t0x0yM1;
	float t0x1y0;
	float t0xM1y0;
	float t0x0y2;
	float t0x0yM2;
	float t0x2y0;
	float t0xM2y0;
	float t0x1y1;
	float t0x1yM1;
	float t0xM1y1;
	float t0xM1yM1;
	
		t0x0y0 = modelGrid[t0x0y0Idx];
	tM1x0y0 = modelGrid[tM1x0y0Idx];
	

	int centreIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0);
int leftIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0);
int rightIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0);
int upIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)-1;
int downIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)+1;

int leftLeftIdx = (get_global_id(1)-2) * get_global_size(0) + get_global_id(0);
int rightRightIdx = (get_global_id(1)+2) * get_global_size(0) + get_global_id(0);
int upUpIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)-2;
int downDownIdx = (get_global_id(1)) * get_global_size(0) + get_global_id(0)+2;

int leftUpIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0)-1;
int rightUpIdx = (get_global_id(1)+1) * get_global_size(0) + get_global_id(0)-1;
int leftDownIdx = (get_global_id(1)-1) * get_global_size(0) + get_global_id(0)+1;
int rightDownIdx = (get_global_id(1)+1) * get_global_size(0) + get_global_id(0)+1;

		t0x0yM1 = modelGrid[t0x0yM1Idx] * (1-boundaryGrid[upIdx]);
		t0x1y0 = modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx]);
		t0x0y1 = modelGrid[t0x0y1Idx]* (1-boundaryGrid[downIdx]);
		t0xM1y0 = modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx]);

		t0x1y1 = modelGrid[t0x1y1Idx]* (1-boundaryGrid[rightDownIdx]);
		t0x1yM1 = modelGrid[t0x1yM1Idx]* (1-boundaryGrid[rightUpIdx]);
		t0xM1y1 = modelGrid[t0xM1y1Idx]* (1-boundaryGrid[leftDownIdx]);
		t0xM1yM1 = modelGrid[t0xM1yM1Idx]* (1-boundaryGrid[leftUpIdx]);

		t0x0y2 = modelGrid[t0x0y2Idx]* (1-boundaryGrid[downDownIdx]);
		t0x2y0 = modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx]);
		t0xM2y0 = modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx]);
		t0x0yM2 = modelGrid[t0x0yM2Idx]* (1-boundaryGrid[upUpIdx]);
	
	//Calculate the next pressure value//
	if(idGrid[centreIdx] == 0)
{t1x0y0 = 0.0;}
if(idGrid[centreIdx] == 1) {
		t1x0y0 = (((2*modelGrid[t0x0y0Idx])+((mu-1.0)*modelGrid[tM1x0y0Idx])+(lambda*(modelGrid[t0x0yM1Idx] * (1-boundaryGrid[upIdx])+modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx])+modelGrid[t0x0y1Idx]* (1-boundaryGrid[downIdx])+modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx])-(4*modelGrid[t0x0y0Idx]))))*(1.0/(mu+1.0)));
}
	if(idGrid[centreIdx] == 2) {
		t1x0y0 = (((2*modelGrid[t0x0y0Idx])+((stringLambda*stringLambda)*(modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx])-(2*t0x0y0)+modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx])))-modelGrid[tM1x0y0Idx])*(1.0/(stringMu+1.0)));
}
	if(idGrid[centreIdx] == 3) {
		t1x0y0 = (((2*modelGrid[t0x0y0Idx])-((1-(sigma*deltaT))*modelGrid[tM1x0y0Idx])-((muTwo*muTwo)*(modelGrid[t0x0y2Idx]* (1-boundaryGrid[downDownIdx])+modelGrid[t0x2y0Idx]* (1-boundaryGrid[rightRightIdx])+modelGrid[t0xM2y0Idx]* (1-boundaryGrid[leftLeftIdx])+modelGrid[t0x0yM2Idx]* (1-boundaryGrid[upUpIdx])))-((2*muTwo*muTwo)*(modelGrid[t0x1y1Idx]* (1-boundaryGrid[rightDownIdx])+modelGrid[t0x1yM1Idx]* (1-boundaryGrid[rightUpIdx])+modelGrid[t0xM1y1Idx]* (1-boundaryGrid[leftDownIdx])+modelGrid[t0xM1yM1Idx]* (1-boundaryGrid[leftUpIdx])))+((8*muTwo*muTwo)*(modelGrid[t0x0yM1Idx] * (1-boundaryGrid[upIdx])+modelGrid[t0x1y0Idx] * (1-boundaryGrid[rightIdx])+modelGrid[t0x0y1Idx]* (1-boundaryGrid[downIdx])+modelGrid[t0xM1y0Idx]* (1-boundaryGrid[leftIdx])))-(20*muTwo*muTwo*modelGrid[t0x0y0Idx]))/(1+(sigma*deltaT)));
}
	
	//If the cell is the listener position, sets the next sound sample in buffer to value contained here//
	if(centreIdx == outputPosition)
	{
		output[idxSample]= t0x0y0;    //@ToDo - Make current timestep centre point auto generated?
	}
	
	if(centreIdx == inputPosition)	//If the position is an excitation...
	{
		t1x0y0 += input[idxSample];	//Input excitation value into point. Then increment to next excitation in next iteration.
	}

if(centreIdx == 21748)
{
t1x0y0 += modelGrid[rotation0 + 6313];
}
if(centreIdx == 66401)
{
t1x0y0 += modelGrid[rotation0 + 224500];
}
	
	modelGrid[t1x0y0Idx] = t1x0y0;
}